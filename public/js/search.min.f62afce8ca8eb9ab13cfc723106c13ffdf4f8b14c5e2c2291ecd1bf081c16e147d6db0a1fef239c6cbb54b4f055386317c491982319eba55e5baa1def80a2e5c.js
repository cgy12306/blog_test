var e,t;e=this,t=function(){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(t)}function t(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function r(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&u(e,t)}function s(e){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function h(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function f(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=s(e);if(t){var i=s(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return h(this,n)}}function l(e){return function(e){if(Array.isArray(e))return d(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(e){if("string"==typeof e)return d(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?d(e,t):void 0}}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function d(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function v(e){return Array.isArray?Array.isArray(e):"[object Array]"===x(e)}function g(e){return"string"==typeof e}function y(e){return"number"==typeof e}function p(e){return!0===e||!1===e||function(e){return m(e)&&null!==e}(e)&&"[object Boolean]"==x(e)}function m(t){return"object"===e(t)}function k(e){return null!=e}function M(e){return!e.trim().length}function x(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":Object.prototype.toString.call(e)}var b=function(e){return"Invalid value for key ".concat(e)},L=function(e){return"Pattern length exceeds max of ".concat(e,".")},S=Object.prototype.hasOwnProperty,_=function(){function e(n){var r=this;t(this,e),this._keys=[],this._keyMap={};var i=0;n.forEach((function(e){var t=w(e);i+=t.weight,r._keys.push(t),r._keyMap[t.id]=t,i+=t.weight})),this._keys.forEach((function(e){e.weight/=i}))}return r(e,[{key:"get",value:function(e){return this._keyMap[e]}},{key:"keys",value:function(){return this._keys}},{key:"toJSON",value:function(){return JSON.stringify(this._keys)}}]),e}();function w(e){var t=null,n=null,r=null,i=1;if(g(e)||v(e))r=e,t=O(e),n=j(e);else{if(!S.call(e,"name"))throw new Error(function(e){return"Missing ".concat(e," property in key")}("name"));var o=e.name;if(r=o,S.call(e,"weight")&&(i=e.weight)<=0)throw new Error(function(e){return"Property 'weight' in key '".concat(e,"' must be a positive integer")}(o));t=O(o),n=j(o)}return{path:t,id:n,weight:i,src:r}}function O(e){return v(e)?e:e.split(".")}function j(e){return v(e)?e.join("."):e}var A=c({},{isCaseSensitive:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:function(e,t){return e.score===t.score?e.idx<t.idx?-1:1:e.score<t.score?-1:1}},{},{includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},{},{location:0,threshold:.6,distance:100},{},{useExtendedSearch:!1,getFn:function(e,t){var n=[],r=!1;return function e(t,i,o){if(k(t))if(i[o]){var c=t[i[o]];if(!k(c))return;if(o===i.length-1&&(g(c)||y(c)||p(c)))n.push(function(e){return null==e?"":function(e){if("string"==typeof e)return e;var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)}(c));else if(v(c)){r=!0;for(var a=0,s=c.length;a<s;a+=1)e(c[a],i,o+1)}else i.length&&e(c,i,o+1)}else n.push(t)}(e,g(t)?t.split("."):t,0),r?n:n[0]},ignoreLocation:!1,ignoreFieldNorm:!1}),I=/[^ ]+/g;function C(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3,t=new Map;return{get:function(n){var r=n.match(I).length;if(t.has(r))return t.get(r);var i=parseFloat((1/Math.sqrt(r)).toFixed(e));return t.set(r,i),i},clear:function(){t.clear()}}}var E=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=n.getFn,i=void 0===r?A.getFn:r;t(this,e),this.norm=C(3),this.getFn=i,this.isCreated=!1,this.setIndexRecords()}return r(e,[{key:"setSources",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.docs=e}},{key:"setIndexRecords",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.records=e}},{key:"setKeys",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];this.keys=t,this._keysMap={},t.forEach((function(t,n){e._keysMap[t.id]=n}))}},{key:"create",value:function(){var e=this;!this.isCreated&&this.docs.length&&(this.isCreated=!0,g(this.docs[0])?this.docs.forEach((function(t,n){e._addString(t,n)})):this.docs.forEach((function(t,n){e._addObject(t,n)})),this.norm.clear())}},{key:"add",value:function(e){var t=this.size();g(e)?this._addString(e,t):this._addObject(e,t)}},{key:"removeAt",value:function(e){this.records.splice(e,1);for(var t=e,n=this.size();t<n;t+=1)this.records[t].i-=1}},{key:"getValueForItemAtKeyId",value:function(e,t){return e[this._keysMap[t]]}},{key:"size",value:function(){return this.records.length}},{key:"_addString",value:function(e,t){if(k(e)&&!M(e)){var n={v:e,i:t,n:this.norm.get(e)};this.records.push(n)}}},{key:"_addObject",value:function(e,t){var n=this,r={i:t,$:{}};this.keys.forEach((function(t,i){var o=n.getFn(e,t.path);if(k(o))if(v(o))!function(){for(var e=[],t=[{nestedArrIndex:-1,value:o}];t.length;){var c=t.pop(),a=c.nestedArrIndex,s=c.value;if(k(s))if(g(s)&&!M(s)){var u={v:s,i:a,n:n.norm.get(s)};e.push(u)}else v(s)&&s.forEach((function(e,n){t.push({nestedArrIndex:n,value:e})}))}r.$[i]=e}();else if(!M(o)){var c={v:o,n:n.norm.get(o)};r.$[i]=c}})),this.records.push(r)}},{key:"toJSON",value:function(){return{keys:this.keys,records:this.records}}}]),e}();function $(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.getFn,i=void 0===r?A.getFn:r,o=new E({getFn:i});return o.setKeys(e.map(w)),o.setSources(t),o.create(),o}function R(e,t){var n=e.matches;t.matches=[],k(n)&&n.forEach((function(e){if(k(e.indices)&&e.indices.length){var n={indices:e.indices,value:e.value};e.key&&(n.key=e.key.src),e.idx>-1&&(n.refIndex=e.idx),t.matches.push(n)}}))}function F(e,t){t.score=e.score}function P(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.errors,r=void 0===n?0:n,i=t.currentLocation,o=void 0===i?0:i,c=t.expectedLocation,a=void 0===c?0:c,s=t.distance,u=void 0===s?A.distance:s,h=t.ignoreLocation,f=void 0===h?A.ignoreLocation:h,l=r/e.length;if(f)return l;var d=Math.abs(a-o);return u?l+d/u:d?1:l}function N(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.minMatchCharLength,n=[],r=-1,i=-1,o=0,c=e.length;o<c;o+=1){var a=e[o];a&&-1===r?r=o:a||-1===r||((i=o-1)-r+1>=t&&n.push([r,i]),r=-1)}return e[o-1]&&o-r>=t&&n.push([r,o-1]),n}function D(e){for(var t={},n=0,r=e.length;n<r;n+=1){var i=e.charAt(n);t[i]=(t[i]||0)|1<<r-n-1}return t}var z=function(){function e(n){var r=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=i.location,c=void 0===o?A.location:o,a=i.threshold,s=void 0===a?A.threshold:a,u=i.distance,h=void 0===u?A.distance:u,f=i.includeMatches,l=void 0===f?A.includeMatches:f,d=i.findAllMatches,v=void 0===d?A.findAllMatches:d,g=i.minMatchCharLength,y=void 0===g?A.minMatchCharLength:g,p=i.isCaseSensitive,m=void 0===p?A.isCaseSensitive:p,k=i.ignoreLocation,M=void 0===k?A.ignoreLocation:k;if(t(this,e),this.options={location:c,threshold:s,distance:h,includeMatches:l,findAllMatches:v,minMatchCharLength:y,isCaseSensitive:m,ignoreLocation:M},this.pattern=m?n:n.toLowerCase(),this.chunks=[],this.pattern.length){var x=function(e,t){r.chunks.push({pattern:e,alphabet:D(e),startIndex:t})},b=this.pattern.length;if(b>32){for(var L=0,S=b%32,_=b-S;L<_;)x(this.pattern.substr(L,32),L),L+=32;if(S){var w=b-32;x(this.pattern.substr(w),w)}}else x(this.pattern,0)}}return r(e,[{key:"searchIn",value:function(e){var t=this.options,n=t.isCaseSensitive,r=t.includeMatches;if(n||(e=e.toLowerCase()),this.pattern===e){var i={isMatch:!0,score:0};return r&&(i.indices=[[0,e.length-1]]),i}var o=this.options,c=o.location,a=o.distance,s=o.threshold,u=o.findAllMatches,h=o.minMatchCharLength,f=o.ignoreLocation,d=[],v=0,g=!1;this.chunks.forEach((function(t){var n=t.pattern,i=t.alphabet,o=t.startIndex,y=function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=r.location,o=void 0===i?A.location:i,c=r.distance,a=void 0===c?A.distance:c,s=r.threshold,u=void 0===s?A.threshold:s,h=r.findAllMatches,f=void 0===h?A.findAllMatches:h,l=r.minMatchCharLength,d=void 0===l?A.minMatchCharLength:l,v=r.includeMatches,g=void 0===v?A.includeMatches:v,y=r.ignoreLocation,p=void 0===y?A.ignoreLocation:y;if(t.length>32)throw new Error(L(32));for(var m,k=t.length,M=e.length,x=Math.max(0,Math.min(o,M)),b=u,S=x,_=d>1||g,w=_?Array(M):[];(m=e.indexOf(t,S))>-1;){var O=P(t,{currentLocation:m,expectedLocation:x,distance:a,ignoreLocation:p});if(b=Math.min(O,b),S=m+k,_)for(var j=0;j<k;)w[m+j]=1,j+=1}S=-1;for(var I=[],C=1,E=k+M,$=1<<k-1,R=0;R<k;R+=1){for(var F=0,D=E;F<D;){var z=P(t,{errors:R,currentLocation:x+D,expectedLocation:x,distance:a,ignoreLocation:p});z<=b?F=D:E=D,D=Math.floor((E-F)/2+F)}E=D;var K=Math.max(1,x-D+1),q=f?M:Math.min(x+D,M)+k,W=Array(q+2);W[q+1]=(1<<R)-1;for(var J=q;J>=K;J-=1){var T=J-1,U=n[e.charAt(T)];if(_&&(w[T]=+!!U),W[J]=(W[J+1]<<1|1)&U,R&&(W[J]|=(I[J+1]|I[J])<<1|1|I[J+1]),W[J]&$&&(C=P(t,{errors:R,currentLocation:T,expectedLocation:x,distance:a,ignoreLocation:p}))<=b){if(b=C,(S=T)<=x)break;K=Math.max(1,2*x-S)}}var V=P(t,{errors:R+1,currentLocation:x,expectedLocation:x,distance:a,ignoreLocation:p});if(V>b)break;I=W}var B={isMatch:S>=0,score:Math.max(.001,C)};if(_){var G=N(w,d);G.length?g&&(B.indices=G):B.isMatch=!1}return B}(e,n,i,{location:c+o,distance:a,threshold:s,findAllMatches:u,minMatchCharLength:h,includeMatches:r,ignoreLocation:f}),p=y.isMatch,m=y.score,k=y.indices;p&&(g=!0),v+=m,p&&k&&(d=[].concat(l(d),l(k)))}));var y={isMatch:g,score:g?v/this.chunks.length:1};return g&&r&&(y.indices=d),y}}]),e}(),K=function(){function e(n){t(this,e),this.pattern=n}return r(e,[{key:"search",value:function(){}}],[{key:"isMultiMatch",value:function(e){return q(e,this.multiRegex)}},{key:"isSingleMatch",value:function(e){return q(e,this.singleRegex)}}]),e}();function q(e,t){var n=e.match(t);return n?n[1]:null}var W=function(e){a(i,e);var n=f(i);function i(e){return t(this,i),n.call(this,e)}return r(i,[{key:"search",value:function(e){var t=e===this.pattern;return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}}],[{key:"type",get:function(){return"exact"}},{key:"multiRegex",get:function(){return/^="(.*)"$/}},{key:"singleRegex",get:function(){return/^=(.*)$/}}]),i}(K),J=function(e){a(i,e);var n=f(i);function i(e){return t(this,i),n.call(this,e)}return r(i,[{key:"search",value:function(e){var t=-1===e.indexOf(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}}],[{key:"type",get:function(){return"inverse-exact"}},{key:"multiRegex",get:function(){return/^!"(.*)"$/}},{key:"singleRegex",get:function(){return/^!(.*)$/}}]),i}(K),T=function(e){a(i,e);var n=f(i);function i(e){return t(this,i),n.call(this,e)}return r(i,[{key:"search",value:function(e){var t=e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,this.pattern.length-1]}}}],[{key:"type",get:function(){return"prefix-exact"}},{key:"multiRegex",get:function(){return/^\^"(.*)"$/}},{key:"singleRegex",get:function(){return/^\^(.*)$/}}]),i}(K),U=function(e){a(i,e);var n=f(i);function i(e){return t(this,i),n.call(this,e)}return r(i,[{key:"search",value:function(e){var t=!e.startsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}}],[{key:"type",get:function(){return"inverse-prefix-exact"}},{key:"multiRegex",get:function(){return/^!\^"(.*)"$/}},{key:"singleRegex",get:function(){return/^!\^(.*)$/}}]),i}(K),V=function(e){a(i,e);var n=f(i);function i(e){return t(this,i),n.call(this,e)}return r(i,[{key:"search",value:function(e){var t=e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[e.length-this.pattern.length,e.length-1]}}}],[{key:"type",get:function(){return"suffix-exact"}},{key:"multiRegex",get:function(){return/^"(.*)"\$$/}},{key:"singleRegex",get:function(){return/^(.*)\$$/}}]),i}(K),B=function(e){a(i,e);var n=f(i);function i(e){return t(this,i),n.call(this,e)}return r(i,[{key:"search",value:function(e){var t=!e.endsWith(this.pattern);return{isMatch:t,score:t?0:1,indices:[0,e.length-1]}}}],[{key:"type",get:function(){return"inverse-suffix-exact"}},{key:"multiRegex",get:function(){return/^!"(.*)"\$$/}},{key:"singleRegex",get:function(){return/^!(.*)\$$/}}]),i}(K),G=function(e){a(i,e);var n=f(i);function i(e){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},c=o.location,a=void 0===c?A.location:c,s=o.threshold,u=void 0===s?A.threshold:s,h=o.distance,f=void 0===h?A.distance:h,l=o.includeMatches,d=void 0===l?A.includeMatches:l,v=o.findAllMatches,g=void 0===v?A.findAllMatches:v,y=o.minMatchCharLength,p=void 0===y?A.minMatchCharLength:y,m=o.isCaseSensitive,k=void 0===m?A.isCaseSensitive:m,M=o.ignoreLocation,x=void 0===M?A.ignoreLocation:M;return t(this,i),(r=n.call(this,e))._bitapSearch=new z(e,{location:a,threshold:u,distance:f,includeMatches:d,findAllMatches:g,minMatchCharLength:p,isCaseSensitive:k,ignoreLocation:x}),r}return r(i,[{key:"search",value:function(e){return this._bitapSearch.searchIn(e)}}],[{key:"type",get:function(){return"fuzzy"}},{key:"multiRegex",get:function(){return/^"(.*)"$/}},{key:"singleRegex",get:function(){return/^(.*)$/}}]),i}(K),H=function(e){a(i,e);var n=f(i);function i(e){return t(this,i),n.call(this,e)}return r(i,[{key:"search",value:function(e){for(var t,n=0,r=[],i=this.pattern.length;(t=e.indexOf(this.pattern,n))>-1;)n=t+i,r.push([t,n-1]);var o=!!r.length;return{isMatch:o,score:o?1:0,indices:r}}}],[{key:"type",get:function(){return"include"}},{key:"multiRegex",get:function(){return/^'"(.*)"$/}},{key:"singleRegex",get:function(){return/^'(.*)$/}}]),i}(K),Q=[W,H,T,U,B,V,J,G],X=Q.length,Y=/ +(?=([^\"]*\"[^\"]*\")*[^\"]*$)/;function Z(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return e.split("|").map((function(e){for(var n=e.trim().split(Y).filter((function(e){return e&&!!e.trim()})),r=[],i=0,o=n.length;i<o;i+=1){for(var c=n[i],a=!1,s=-1;!a&&++s<X;){var u=Q[s],h=u.isMultiMatch(c);h&&(r.push(new u(h,t)),a=!0)}if(!a)for(s=-1;++s<X;){var f=Q[s],l=f.isSingleMatch(c);if(l){r.push(new f(l,t));break}}}return r}))}var ee=new Set([G.type,H.type]),te=function(){function e(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=r.isCaseSensitive,o=void 0===i?A.isCaseSensitive:i,c=r.includeMatches,a=void 0===c?A.includeMatches:c,s=r.minMatchCharLength,u=void 0===s?A.minMatchCharLength:s,h=r.ignoreLocation,f=void 0===h?A.ignoreLocation:h,l=r.findAllMatches,d=void 0===l?A.findAllMatches:l,v=r.location,g=void 0===v?A.location:v,y=r.threshold,p=void 0===y?A.threshold:y,m=r.distance,k=void 0===m?A.distance:m;t(this,e),this.query=null,this.options={isCaseSensitive:o,includeMatches:a,minMatchCharLength:u,findAllMatches:d,ignoreLocation:f,location:g,threshold:p,distance:k},this.pattern=o?n:n.toLowerCase(),this.query=Z(this.pattern,this.options)}return r(e,[{key:"searchIn",value:function(e){var t=this.query;if(!t)return{isMatch:!1,score:1};var n=this.options,r=n.includeMatches;e=n.isCaseSensitive?e:e.toLowerCase();for(var i=0,o=[],c=0,a=0,s=t.length;a<s;a+=1){var u=t[a];o.length=0,i=0;for(var h=0,f=u.length;h<f;h+=1){var d=u[h],v=d.search(e),g=v.isMatch,y=v.indices,p=v.score;if(!g){c=0,i=0,o.length=0;break}if(i+=1,c+=p,r){var m=d.constructor.type;ee.has(m)?o=[].concat(l(o),l(y)):o.push(y)}}if(i){var k={isMatch:!0,score:c/i};return r&&(k.indices=o),k}}return{isMatch:!1,score:1}}}],[{key:"condition",value:function(e,t){return t.useExtendedSearch}}]),e}(),ne=[];function re(e,t){for(var n=0,r=ne.length;n<r;n+=1){var i=ne[n];if(i.condition(e,t))return new i(e,t)}return new z(e,t)}var ie="$and",oe="$or",ce="$path",ae="$val",se=function(e){return!(!e[ie]&&!e[oe])},ue=function(e){return!!e[ce]},he=function(e){return!v(e)&&m(e)&&!se(e)},fe=function(e){return i({},ie,Object.keys(e).map((function(t){return i({},t,e[t])})))},le=function(){function e(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=arguments.length>2?arguments[2]:void 0;t(this,e),this.options=c({},A,{},r),this.options.useExtendedSearch,this._keyStore=new _(this.options.keys),this.setCollection(n,i)}return r(e,[{key:"setCollection",value:function(e,t){if(this._docs=e,t&&!(t instanceof E))throw new Error("Incorrect 'index' type");this._myIndex=t||$(this.options.keys,this._docs,{getFn:this.options.getFn})}},{key:"add",value:function(e){k(e)&&(this._docs.push(e),this._myIndex.add(e))}},{key:"remove",value:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){return!1},t=[],n=0,r=this._docs.length;n<r;n+=1){var i=this._docs[n];e(i,n)&&(this.removeAt(n),n-=1,r-=1,t.push(i))}return t}},{key:"removeAt",value:function(e){this._docs.splice(e,1),this._myIndex.removeAt(e)}},{key:"getIndex",value:function(){return this._myIndex}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.limit,r=void 0===n?-1:n,i=this.options,o=i.includeMatches,c=i.includeScore,a=i.shouldSort,s=i.sortFn,u=i.ignoreFieldNorm,h=g(e)?g(this._docs[0])?this._searchStringList(e):this._searchObjectList(e):this._searchLogical(e);return de(h,{ignoreFieldNorm:u}),a&&h.sort(s),y(r)&&r>-1&&(h=h.slice(0,r)),ve(h,this._docs,{includeMatches:o,includeScore:c})}},{key:"_searchStringList",value:function(e){var t=re(e,this.options),n=this._myIndex.records,r=[];return n.forEach((function(e){var n=e.v,i=e.i,o=e.n;if(k(n)){var c=t.searchIn(n),a=c.isMatch,s=c.score,u=c.indices;a&&r.push({item:n,idx:i,matches:[{score:s,value:n,norm:o,indices:u}]})}})),r}},{key:"_searchLogical",value:function(e){var t=this,n=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.auto,i=void 0===r||r,o=function e(n){var r=Object.keys(n),o=ue(n);if(!o&&r.length>1&&!se(n))return e(fe(n));if(he(n)){var c=o?n[ce]:r[0],a=o?n[ae]:n[c];if(!g(a))throw new Error(b(c));var s={keyId:j(c),pattern:a};return i&&(s.searcher=re(a,t)),s}var u={children:[],operator:r[0]};return r.forEach((function(t){var r=n[t];v(r)&&r.forEach((function(t){u.children.push(e(t))}))})),u};return se(e)||(e=fe(e)),o(e)}(e,this.options),r=this._myIndex.records,i={},o=[];return r.forEach((function(e){var r=e.$,c=e.i;if(k(r)){var a=function e(n,r,i){if(!n.children){var o=n.keyId,c=n.searcher,a=t._findMatches({key:t._keyStore.get(o),value:t._myIndex.getValueForItemAtKeyId(r,o),searcher:c});return a&&a.length?[{idx:i,item:r,matches:a}]:[]}switch(n.operator){case ie:for(var s=[],u=0,h=n.children.length;u<h;u+=1){var f=e(n.children[u],r,i);if(!f.length)return[];s.push.apply(s,l(f))}return s;case oe:for(var d=[],v=0,g=n.children.length;v<g;v+=1){var y=e(n.children[v],r,i);if(y.length){d.push.apply(d,l(y));break}}return d}}(n,r,c);a.length&&(i[c]||(i[c]={idx:c,item:r,matches:[]},o.push(i[c])),a.forEach((function(e){var t,n=e.matches;(t=i[c].matches).push.apply(t,l(n))})))}})),o}},{key:"_searchObjectList",value:function(e){var t=this,n=re(e,this.options),r=this._myIndex,i=r.keys,o=r.records,c=[];return o.forEach((function(e){var r=e.$,o=e.i;if(k(r)){var a=[];i.forEach((function(e,i){a.push.apply(a,l(t._findMatches({key:e,value:r[i],searcher:n})))})),a.length&&c.push({idx:o,item:r,matches:a})}})),c}},{key:"_findMatches",value:function(e){var t=e.key,n=e.value,r=e.searcher;if(!k(n))return[];var i=[];if(v(n))n.forEach((function(e){var n=e.v,o=e.i,c=e.n;if(k(n)){var a=r.searchIn(n),s=a.isMatch,u=a.score,h=a.indices;s&&i.push({score:u,key:t,value:n,idx:o,norm:c,indices:h})}}));else{var o=n.v,c=n.n,a=r.searchIn(o),s=a.isMatch,u=a.score,h=a.indices;s&&i.push({score:u,key:t,value:o,norm:c,indices:h})}return i}}]),e}();function de(e,t){var n=t.ignoreFieldNorm,r=void 0===n?A.ignoreFieldNorm:n;e.forEach((function(e){var t=1;e.matches.forEach((function(e){var n=e.key,i=e.norm,o=e.score,c=n?n.weight:null;t*=Math.pow(0===o&&c?Number.EPSILON:o,(c||1)*(r?1:i))})),e.score=t}))}function ve(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.includeMatches,i=void 0===r?A.includeMatches:r,o=n.includeScore,c=void 0===o?A.includeScore:o,a=[];return i&&a.push(R),c&&a.push(F),e.map((function(e){var n=e.idx,r={item:t[n],refIndex:n};return a.length&&a.forEach((function(t){t(e,r)})),r}))}return le.version="6.4.3",le.createIndex=$,le.parseIndex=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t.getFn,r=void 0===n?A.getFn:n,i=e.keys,o=e.records,c=new E({getFn:r});return c.setKeys(i),c.setIndexRecords(o),c},le.config=A,function(){ne.push.apply(ne,arguments)}(te),le},"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).Fuse=t();;const idx=[{"link":"/docs/kronol/","title":"KRONOL Docs","body":"[Welcome to the Compose theme user guide! This guide shows you how to get started creating technical documentation sites using Compose, including site customization and how to use Compose's blocks and templates. Get started now]".toLowerCase(),},{"link":"/docs/","title":"Overview","body":"[Pre-View Driver is software components that intermediate communication between a device and an Operating System. Since kernel level privileges are required to use the device, the driver has the kernel level privilege level as well. If there are security flaws in the driver, unlike user land applications, it can lead to serious problems in which Windows kernel privileges are violated. There have been many efforts to improve the security of Windows drivers, but there have been many difficulties in applying effective testing techniques such as fuzzing (Fuzzing is a technique that automatically generates inputs and injects them into a program to check for bugs and software defects. It is used in various fields to test stability and security by detecting defects that are difficult for humans to predict.) compared to user land applications. Since the driver is loaded into kernel memory, we must access the kernel space to test driver stability. It is very difficult to apply fuzzing to this kernel component. Especially, it is even more difficult to apply coverage-guided fuzzing to the kernel. At the kernel level, the driver handles application requests in the form of a structure called IRP(I/O Request Packet). More specifically, the DispatchDeviceControl that exists inside the driver handles each routine corresponding to the IOCTL CODE, which is the handler code contained in the IRP sent from the outside of the driver. At this time, access to the routine is determined by various constraints such as inputBuffer contents and inputBufferLength for each routine. In addition, there are cases in which the execution of other routines must precede the execution of a specific routine in the driver. The typical case mentioned above is a case where a global variable set in one routine is used in another routine. We express this situation as an ordering dependency between IOCTL routines. In order to apply fuzzing to Driver without problem, information about the driver interface is required: that satisfies the constraints and dependencies of IOCTL CODE. Even in order to apply coverage-guided fuzzing to the kernel level, coverage measurement at the kernel level and consideration of the driver interface must be preceded. These causes have made it difficult to fuzz the kernel and driver. So, team driverThru tried to solve these two problems. As we continued our research, we found several ways to solve them, and developed a simple and fast driver fuzzing framework applying these solutions. We hope this tool is useful for improving the stability of Windows drivers and kernel environments. IREC Even in order to apply coverage-guided fuzzing to the kernel level, coverage measurement at the kernel level and consideration of the driver interface must be preceded. These causes have made it difficult to fuzz the kernel and driver. So, team driverThru tried to solve these two problems. As we continued our research, we found several ways to solve them, and developed a simple and fast driver fuzzing framework applying these solutions. We hope this tool is useful for improving the stability of Windows drivers and kernel environments. In addition, the driver has different constraints for access to each of the IOCTL routines. Therefore, in order to apply the driver to the fuzzer, we have to find the contraints manually. Furthermore, since most of the drivers are distributed in the form of closed sources (.sys), Furthermore, since most of the drivers are distributed in the form of closed source (.sys), Reverse Engineering is required to obtain driver interface information. It is very inefficient to do this manually every time before you start fuzzing. It is very inefficient to do this manually every time before you start fuzzing. Even if this is possible, there is no guarantee that mistakes and false positives will not exist. Humans are not machines. The team driverThru wanted to develop a tool that can easily recovery the structure of numerous drivers to increase the efficiency of kernel fuzzing. That is how IREC (Interface RECovery) was born. IREC tool automatically extracts Driver interface information and constraints such as IOCTL CODE, InputBufferLength, OutBufferLength of driver in the form of .json file using angr framework, Symbolic Execution and radare2. The generated .json file is used as the kAFL agent code in the execution routine of IRPT (I/O Request &amp; Intel-PT based Fuzzer?) later. Using IREC, we can extract the interface information and constraints of the wdm driver very easily and quickly without any further inefficient manual work. Fuzzer kAFL: Hardware-Assisted Feedback Fuzzing for OS Kernels noted that non-determinism due to kernel-space interrupts, kernel threads, statefulness, and similar mechanisms makes kernel fuzzing more difficult. The kernel region has a memory structure different from that of the user land, and the execution flow can be changed by various unexpected requests such as interrupts. So it is not easy to perform a fuzzing test focusing only on a specific target region. In addition, instrumentation is required to receive feedback on coverage increase or decrease by executing the fuzzing routine. In the case of open source user land applications, it is possible to easily measure coverage by using a code compilation technique such as AFL instrumentation, but since the Windows kernel is closed source, it is impossible to use the instrumentation technique to modify the inside of the code. Accordingly, KRONOL borrowed the idea of using Intel-PT technology in the fuzzer from KAFL to measure the increase or decrease of coverage in the kernel. In addition, we modified the KVM-PT, QEMU-PT and hypercall communication technology developed by kAFL to implement communication between the VM loaded with the target driver and the fuzzer performing the mutation. kAFL is a very nice tool in that it enables hardware-assisted kernel fuzzing that is not dependent on the OS, but it is far from the ideal fuzzer that the driverThru team pursues. The reason is that kAFL targets only a single IOCTL CODE. This means that the ordering dependency that exists between IOCTL routines cannot be considered. Therefore, the driverThru team tried to develop a fuzzer that solves the problems that kAFL cannot solve. Based on driver interface information that can be easily obtained using IREC. Brute-Force OneCode Fuzzer So the first fuzzer developed by the DriverThru team is the Brute-Force OneCode Fuzzer. Brute-Force OneCode Fuzzer sends one IOCTL CODE per fuzzing routine to target driver considering only constraints such as inputBuffer and inputBufferLength obtained from IREC. However, since only one IOCTL CODE is sended in one fuzzing routine, it is difficult to expect the dependency between driver routines to be satisfied only with the payload. Furthermore, kAFL reflects only the feedback result from the most recent fuzzing routine, even though the existing routines have contributed largely to coverage extension. Although the previous fuzzing routine satisfies the ordering dependency and thus the coverage of the last executed fuzzing routine could be increased, all contributions to the previous routine are ignored when coverage feedback is reflected. As such, Brute-Force OneCode Fuzzer completely relies on luck to satisfy the ordering dependency between IOCTL routines during fuzzing. Even if the fuzzer finds a crash fortunately, there is a fatal drawback that all payloads sent to target driver during fuzzing must be delivered to the driver in order to reproduce. Brute-Force MultiCode Fuzzer The second fuzzer of team driverThru developed to solve the fatal problem of Brute-Force OneCode Fuzzer is Brute-Force MultiCode Fuzzer. Brute-Force MultiCode Fuzzer decodes the payload generated by the mutation, devides it into several IOCTL codes, and sends them to target driver. As a result, it is possible to satisfy the ordering dependency between IOCTL routines by delivering only one payload to the driver. 그러나 Brute-Force MultiCode Fuzzer에도 단점이 존재했다. Brute-Force MultiCode Fuzzer는 드라이버에 보내기 직전의 페이로드를 IOCTL CODE와 inputBeffer로 디코드하는 방식을 이용했다. 퍼저가 뮤테이션 단계에서 페이로드의 구조를 모르는 것이 Brute-Force MultiCode Fuzzer의 치명적인 단점이다. 이를 바꾸어 이야기 하면, IOCTL CODE와 inputBuffer를 퍼저가 능동적으로 구분하여 뮤테이션을 진행하지 못한다는 것이다. Brute-Force라는 단어가 퍼저의 이름에 들어간 이유는 바로 이러한 이유 때문이다. 퍼저는 페이로드를 생성할때, Driver interface를 전혀 고려하지 않고 뮤테이션을 진행한다는 점에서 분명한 운적 요소(Lucky!, 우효!)가 존재하기 때문이다. driverThru팀은 효율적인 드라이버 퍼징 프레임워크 구축을 위해 Brute-Force MultiCode Fuzzer도 Driver의 안정성 테스트를 위한 이상적인 퍼저에 적합하지 않다고 판단했다. IRPT 퍼저가 무작위로 만든 하나의 페이로드를 여러개의 IOCTL CODE로 보내는 것을 넘어, 각 IOCTL CODE, inputBuffer, IOCTL CODE의 전송 순서 등의 dependency를 퍼저가 능동적으로 판단하여 각각 뮤테이션을 진행하는 기술을 구현할 수 있으면 좋겠다고 생각했고, 이를 위해 새롭게 개발한 퍼저가 바로 IRPT이다. IRPT는 IRP Program 이라는 단위로 IRP 패킷들을 묶어 뮤테이션을 진행하고, 이 IRP Program을 하나의 페이로드로 드라이버에게 전송하는 퍼저이다. Program 내부에 있는 각 IRP에 대한 IOCTL CODE와 inputBuffer 값들을 뮤테이션 하는 것은 물론, IRP의 순서에 대한 뮤테이션도 진행한다. 앞서 언급했던 두개의 Brute-force Fuzzer와 차별화 되는 IRPT만의 특징이자 가장 큰 장점은 바로 IRP의 순서에 대한 뮤테이션이 가능하다는 점이다. 선행되는 IOCTL 루틴으로 dependency가 충족되어 이후 IOCTL 루틴의 커버리지가 증가 한 경우, 커버리지의 증가를 야기한 루틴의 선후 관계를 퍼저가 이해하고 다음 뮤테이션에 이를 반영할 수 있다. 이로써 기존의 퍼저들에서 해결하지 못한 문제들을 성공적으로 해결하고, 효율적인 드라이버 퍼징을 실현할 수 있었다. KRONOL Docs]".toLowerCase(),},{"link":"/docs/kronol/achivement/","title":"Achivements","body":"[]".toLowerCase(),},{"link":"/docs/kronol/internal/","title":"Internal","body":"[IREC IRPT IRCAP]".toLowerCase(),},{"link":"/docs/kronol/user_guide/","title":"User guide","body":"[IREC What is IREC A cross platform framework to recover driver's communication interface. It aims to recover communication interface for fuzzing a kernel driver. IREC structure IREC ├── test-drivers # Test drivers to verify that madcore is working. ├── projects # Driver analysis projects │ ├── symbolic # Techniques using symbolic execution. │ ├── static # Techniques using static analysis techniques │ └──wdm.py # WDM driver analysis framework └── irec.py # Main module Install We recommend python3.8 virtual environment to use IREC. 1 2 3 4 5 6 7 8 9 # install virtualenv $ pip install virtualenv $ pip install virtualenvwrapper # make virtual environment $ virtualenv [virtual env name] $ source [virtual env name]/bin/activate $ deactivate It requires angr, radare2 to use symbolic-analysis and static-analysis. 1 2 3 4 5 6 7 # use symbolic-analysis $ pip install angr boltons argparse ipdb # use static-analysis $ apt install radare2 $ pip install r2pipe IRPT Getting started This project is based on kAFL: HW-assisted Feedback Fuzzing for x86 Kernels. So, there is overlapping parts on Installation. Installation requires multiple components, some of which can depend on Internet connectivity and defaults of your distribution / version. It is recommended to install step by step. 1 2 3 4 5 6 $ git clone [irpt] $ cd ~/kafl $ ./install.sh deps # check platform and install dependencies $ ./install.sh perms # allow current user to control KVM (/dev/kvm) $ ./install.sh qemu # git clone qemu-pt and build Qemu $ ./install.sh linux # git clone kvm-pt and build Linux It is safe to re-execute any of these commands after failure, for example if not all dependencies could have been downloaded. The final step does not automatically install the new Linux kernel but only gives some default instructions. Install according to your preference/distribution defaults, or simply follow the suggested steps: 1 $ ./install.sh note After reboot, make sure the new kernel is booted and PT support is detected by KVM: 1 2 3 $ sudo reboot $ dmesg|grep VMX [VMX-PT] Info: CPU is supported! You must set the correct path to the Qemu binary in kAFL-Fuzzer/irpt.ini. Launch irpt.py to get a help message with the detailed list of parameters: 1 $ python3 ~/kafl/kAFL-Fuzzer/kafl_fuzz.py -h Setting Qemu Before you launch irpt.py, you should be take a snapshot of Qemu with loader.exe. loader.exe is a file to load a target driver and agent.exe. Compile loader.c file to loader.exe: 1 $ ~/irpt/targets/compile_loader.sh If you prepare the binary in targets/bin/loader.exe, you can launch vm.py to take a snapshot of Qemu. Launch vm.py to get a help message with the detailed list of parameters: 1 $ python vm.py Caution! Snapshot mode is not available to access internet. You can launch `vm.py` with boot mode and download the binary inside the Qemu first. IRCAP You should compile a driver that can capture the IRP from target driver. It saves the captured IRP file. You can use the file to select the seed when IRPT is launched. Monitor You can monitor the fuzzer while it is running. We tried to make afl style to make it easier to recognize. There may be some side effects because It's an experimental function. Monitor mode on/off You can use the monitor mode if you just add -tui option. 1 $ python irpt.py ... -mode fuzz -tui Process timing +----------------------------------------------------+ | run time : 0 days, 1 hrs, 30 min, 43 sec | | last new path : 0 days, 0 hrs, 5 min, 40 sec | | last uniq crash : none seen yet | | last uniq hang : 0 days, 1 hrs, 24 min, 32 sec | +----------------------------------------------------+ This section tells you how long the fuzzer has been running and how much time has elapsed since its most resent finds. This is broken down into &quot;paths&quot; (a shorthand for corpus that trigger new execution patterns), crashes, and hangs. There’s one important thing to watch out for: if the tool is not finding new paths within several minutes of starting, you’re probably not invoking the target driver correctly and it never gets to parse the input files we’re throwing at it. The input file should be follow the IRP program format. Overall results +-----------------------+ | cycles done : 40 | | total paths : 12 | | uniq crashes : 0 | | uniq hangs : 1 | +-----------------------+ The first field in this section gives you the count of program mutates done so far - that is, the number of times the program that is input corpus went over all mutation logic. After the program finish a cycle, it creates a new program through the optimizer or executes a next cycle in order of the program in which they are scored. The next field shows you the number of different paths each program passes each time it is sent to the target driver. You can recognize the program is being mutated to find new coverages. The remaining fields is the number of unique faults. The test cases, crashes, and hangs can be explored in real-time by browsing the out directory, as discussed in Interpreting output. Cycle progress +-------------------------------------+ | now processing : 14 | | total programs : 13 (4 unique) | +-------------------------------------+ The box tells you how far along the fuzzer is with the cycle. It shows the ID of the program it is currently working on. The total programs is all program that is made by the fuzzer and if the Map coverage +--------------------------------------+ | total edges : 77 | | map density : 0.01% / 0.06% | +--------------------------------------+ The section provides some trivia about the coverage observed by the target binary. The first line in the box deals with the counts of branch tuples the fuzzer has hit in the binary. The other line in the box tells you how many branch tuples the fuzzer has already hit, in proportion to how much the bitmap can hold. The number on the left describes the current program, the one on the right is the value for the entire corpus. Stage progress +-------------------------------------+ | now trying : AFLdetermin | | stage yields : 4/48.7k (0.01%) | | total execs : 76.2k | | exec speed : 1104/sec | +-------------------------------------+ This part gives you an in-depth peek at what the fuzzer is actually doing right now. It tells you about the current stage. AFLdetermin: a mutation logic with a pre-made formula without random intervention. It was designed in the same arithmetic logic of afl. splice: a last-resort strategy that kicks in after the first full queue cycle with no new paths. It is equivalent to ‘havoc’, except that it first splices together two random inputs from the program at some arbitrarily selected midpoint. insertIRP: a stage that new IRP packets containing another IOCTL codes are placed in the program. swapIRP: a mutation stage of the IRPs sequence. Several IRP packets are placed in a single program. The order dependency can meet by the sequence of transferring IRPs. removeIRP: a stage that removes IRP in the program. havoc: a sort-of-fixed-length cycle with stacked random tweaks. The operations attempted during this stage include bit flips, overwrites with random integers, block deletion, block duplication, plus assorted dictionary-related operations. There’s the exec count progress indicator for the current stage, a global exec counter, and a benchmark for the current program execution speed. It's based on the execution criteria of the fuzzer that it sends an IRP to target driver once. Findings in depth +--------------------------------------+ | favored paths : 0 (0.00%) | | new edges on : 10 | | total crashes : 0 (0 unique) | | total tmouts : 1 (1 unique) | +--------------------------------------+ This gives you several metrics that are of interest mostly to complete nerds. The section includes the number of paths that the fuzzer likes the most based on a minimization algorithm baked into the code (these will get considerably more air time), and the last test cases that actually resulted in better edge coverage. There are also additional, more detailed counters for crashes and hangs. The last two sections tell the total / unique counters of crashes and hangs. In irpt, crasher algorithm checks if newer crash / hang is produced in same context with crash / hang made before. In last line, Tmout counter indicates exactly the same thing to hang in irpt. Fuzzing strategy yields +-----------------------------------------------------+ | insertIRP : 0/5327 | | swapIRP : 5/4003 | | mutateArg : 8/7749 | | AFLdetermin : 9/23.0k | | splice : 10/11.8k | | removeIRP : 0/21.0k | +-----------------------------------------------------+ This is just another nerd-targeted section keeping track of how many paths we have netted, in proportion to the number of execs attempted, for each of the fuzzing strategies discussed earlier on. This serves to convincingly validate assumptions about the usefulness of the various approaches taken by irpt. Path geometry +---------------------+ | level : 3 | | pending : 7 | | pend fav : 2 | | uniq prog : 7 | | reload : 0 | +---------------------+ The first field in this section tracks the path depth reached through the guided fuzzing process. In essence: the initial test cases supplied by the user are considered “level 1”. The test cases that can be derived from that through traditional fuzzing are considered “level 2”; the ones derived by using these as inputs to subsequent fuzzing rounds are “level 3”; and so forth. The maximum depth is therefore a rough proxy for how much value you’re getting out of the instrumentation-guided approach taken by irpt. The next field shows you the number of inputs that have not gone through any fuzzing yet. The same stat is also given for “favored” entries that the fuzzer really wants to get to in this database cycle (the non-favored entries may have to wait probabilistically to get their chance). Last, we have the number of unique programs found during this fuzzing section and number of VMs reloaded by crash / hangs. In irpt, if fault events is occurred, VM(Qemu instance) is to be shut downed then restarted.]".toLowerCase(),},{"link":"/","title":"KRONOL","body":"[KRONOL. KRONOL is windows kernel fuzzer and recovers interface is used fuzzing of driver. Read the Docs Download Fuzzer]".toLowerCase(),},{"link":"/search/","title":"Search","body":"[]".toLowerCase(),},];const searchKeys=['title','link','body','id'];const searchPageElement=elem('#searchpage');const searchOptions={ignoreLocation:true,findAllMatches:true,includeScore:true,shouldSort:true,keys:searchKeys,threshold:0.0};const index=new Fuse(idx,searchOptions);function minQueryLen(query){query=query.trim();const queryIsFloat=parseFloat(query);const minimumQueryLength=queryIsFloat?1:2;console.log(query,queryIsFloat,minimumQueryLength);return minimumQueryLength;}
function searchResults(results=[],query="",passive=false){let resultsFragment=new DocumentFragment();let showResults=elem('.search_results');if(passive){showResults=searchPageElement;}
emptyEl(showResults);const queryLen=query.length;const requiredQueryLen=minQueryLen(query);if(results.length&&queryLen>=requiredQueryLen){console.log('hmm');let resultsTitle=createEl('h3');resultsTitle.className='search_title';resultsTitle.innerText=quickLinks;if(passive){resultsTitle.innerText=searchResultsLabel;}
resultsFragment.appendChild(resultsTitle);if(!searchPageElement){results=results.slice(0,8);}else{results=results.slice(0,12);}
results.forEach(function(result){let item=createEl('a');item.href=`${result.link}?query=${query}`;item.className='search_result';item.style.order=result.score;if(passive){pushClass(item,'passive');let itemTitle=createEl('h3');itemTitle.textContent=result.title;item.appendChild(itemTitle);let itemDescription=createEl('p');let queryInstance=result.body.indexOf(query);itemDescription.textContent=`... ${result.body.substring(queryInstance,queryInstance+200)} ...`;item.appendChild(itemDescription);}else{item.textContent=result.title;}
resultsFragment.appendChild(item);});}
if(queryLen>=requiredQueryLen){if(!results.length){showResults.innerHTML=`<span class="search_result">${noMatchesFound}</span>`;}}else{if(queryLen>1){showResults.innerHTML=`<label for="find" class="search_result">${shortSearchQuery}</label>`;}else{showResults.innerHTML=`<label for="find" class="search_result">${typeToSearch}</label>`;}}
showResults.appendChild(resultsFragment);}
function search(searchTerm,passive=false){if(searchTerm.length){let rawResults=index.search(searchTerm);rawResults=rawResults.map(function(result){const score=result.score;const resultItem=result.item;resultItem.score=(parseFloat(score)*50).toFixed(0);return resultItem;});passive?searchResults(rawResults,searchTerm,true):searchResults(rawResults,searchTerm);}else{passive?searchResults([],"",true):searchResults();}}
function liveSearch(){const searchField=elem('.search_field');if(searchField){searchField.addEventListener('input',function(){const searchTerm=searchField.value.trim().toLowerCase();search(searchTerm);});if(!searchPageElement){searchField.addEventListener('search',function(){const searchTerm=searchField.value.trim().toLowerCase();if(searchTerm.length){window.location.href=`${parentURL}search/?query=${searchTerm}`;}});}}}
function findQuery(query='query'){const urlParams=new URLSearchParams(window.location.search);if(urlParams.has(query)){let c=urlParams.get(query);return c;}
return "";}
function passiveSearch(){if(searchPageElement){const searchTerm=findQuery();search(searchTerm,true);const searchField=elem('.search_field');if(searchField){searchField.addEventListener('input',function(){const searchTerm=searchField.value.trim().toLowerCase();search(searchTerm,true);wrapText(searchTerm,main);});}}}
function hasSearchResults(){const searchResults=elem('.results');const body=searchResults.innerHTML.length;return[searchResults,body]}
function clearSearchResults(){let searchResults=hasSearchResults();let actionable=searchResults[1];if(actionable){searchResults=searchResults[0];searchResults.innerHTML="";const searchField=elem('.search_field');searchField.value="";}}
function onEscape(fn){window.addEventListener('keydown',function(event){if(event.code==="Escape"){fn();}});}
let main=elem('main');if(!main){main=elem('.main');}
window.addEventListener('load',function(){searchPageElement?false:liveSearch();passiveSearch();wrapText(findQuery(),main);onEscape(clearSearchResults);});window.addEventListener('click',function(event){const target=event.target;const isSearch=target.closest('.search')||target.matches('.search');if(!isSearch&&!searchPageElement){clearSearchResults();}});